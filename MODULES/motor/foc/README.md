# FOC ç®—æ³•æ¨¡å—è¯¦ç»†æ–‡æ¡£

## ğŸ“š ç›®å½•

- [æ¦‚è¿°](#æ¦‚è¿°)
- [ç›®å½•ç»“æ„](#ç›®å½•ç»“æ„)
- [æ ¸å¿ƒç®—æ³•](#æ ¸å¿ƒç®—æ³•)
  - [FOC ç”µæµç¯ç®—æ³•](#foc-ç”µæµç¯ç®—æ³•)
  - [Clarke åæ ‡å˜æ¢](#clarke-åæ ‡å˜æ¢)
  - [Park åæ ‡å˜æ¢](#park-åæ ‡å˜æ¢)
  - [SVPWM è°ƒåˆ¶](#svpwm-è°ƒåˆ¶)
- [æ•°å­¦å…¬å¼è¯¦è§£](#æ•°å­¦å…¬å¼è¯¦è§£)
- [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
- [ä½¿ç”¨ç¤ºä¾‹](#ä½¿ç”¨ç¤ºä¾‹)

---

## æ¦‚è¿°

FOC (Field Oriented Controlï¼Œç£åœºå®šå‘æ§åˆ¶) æ˜¯ä¸€ç§é«˜æ€§èƒ½çš„äº¤æµç”µæœºæ§åˆ¶æ–¹æ³•ã€‚æœ¬æ¨¡å—å®ç°äº†å®Œæ•´çš„ FOC ç®—æ³•ï¼ŒåŒ…æ‹¬ï¼š

- **åæ ‡å˜æ¢**ï¼šClarke å˜æ¢ (abc â†’ Î±Î²)ã€Park å˜æ¢ (Î±Î² â†’ dq)
- **ç”µæµæ§åˆ¶**ï¼šdq è½´ç‹¬ç«‹ PI æ§åˆ¶å™¨ï¼Œå¸¦å‰é¦ˆè§£è€¦
- **PWM è°ƒåˆ¶**ï¼šç©ºé—´çŸ¢é‡ PWM (SVPWM)
- **æ•°å­¦ä¼˜åŒ–**ï¼šå¿«é€Ÿä¸‰è§’å‡½æ•°æŸ¥æ‰¾è¡¨

**æ ¸å¿ƒä¼˜åŠ¿**ï¼š
- âœ… **çº¯å‡½æ•°è®¾è®¡**ï¼šæ— ç¡¬ä»¶ä¾èµ–ï¼Œæ˜“äºæµ‹è¯•å’Œç§»æ¤
- âœ… **é«˜æ€§èƒ½**ï¼šä¼˜åŒ–çš„æ•°å­¦è¿ç®—ï¼Œæ”¯æŒ 20kHz æ§åˆ¶é¢‘ç‡
- âœ… **æ¨¡å—åŒ–**ï¼šæ¸…æ™°çš„æ¥å£ï¼Œæ–¹ä¾¿é›†æˆå’Œæ‰©å±•

---

## ç›®å½•ç»“æ„

```
foc/
â”œâ”€â”€ foc_algorithm.c/h       # FOC ä¸»ç®—æ³•ï¼ˆç”µæµç¯æ§åˆ¶ï¼‰
â”œâ”€â”€ clarke.c/h              # Clarke åæ ‡å˜æ¢
â”œâ”€â”€ park.c/h                # Park åæ ‡å˜æ¢
â”œâ”€â”€ svpwm.c/h               # ç©ºé—´çŸ¢é‡ PWM è°ƒåˆ¶
â”œâ”€â”€ trigonometry.c/h        # å¿«é€Ÿä¸‰è§’å‡½æ•°
â””â”€â”€ math_common.h           # æ•°å­¦å¸¸æ•°ä¸å·¥å…·å‡½æ•°
```

---

## æ ¸å¿ƒç®—æ³•

### FOC ç”µæµç¯ç®—æ³•

FOC ç”µæµç¯æ˜¯æ•´ä¸ªç®—æ³•çš„æ ¸å¿ƒï¼Œå®ç°äº†ä»ä¸‰ç›¸ç”µæµåé¦ˆåˆ°ä¸‰ç›¸ PWM å ç©ºæ¯”çš„å®Œæ•´è®¡ç®—è¿‡ç¨‹ã€‚

#### ç®—æ³•æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ia, Ib, Ic  â”‚ ä¸‰ç›¸ç”µæµé‡‡æ ·
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Clarke    â”‚ abc â†’ Î±Î² å˜æ¢
â”‚  Transform  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Park     â”‚ Î±Î² â†’ dq å˜æ¢ï¼ˆéœ€è¦ç”µè§’åº¦ Î¸ï¼‰
â”‚  Transform  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   æ»¤æ³¢å™¨     â”‚ ä¸€é˜¶ä½é€šæ»¤æ³¢
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PI æ§åˆ¶å™¨   â”‚ è¯¯å·® = Id_ref - Id, Iq_ref - Iq
â”‚  (dè½´/qè½´)  â”‚ Vd = KpÂ·err_d + âˆ«KiÂ·err_d
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  å‰é¦ˆè§£è€¦    â”‚ è¡¥å¿ dq è½´è€¦åˆ
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç”µå‹çŸ¢é‡é™å¹… â”‚ é™åˆ¶åœ¨å¯è°ƒåˆ¶èŒƒå›´å†…
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  é€† Park    â”‚ dq â†’ Î±Î² å˜æ¢
â”‚  Transform  â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    SVPWM    â”‚ Î±Î² â†’ PWM å ç©ºæ¯”
â”‚  Modulate   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Ta, Tb, Tc  â”‚ ä¸‰ç›¸ PWM å ç©ºæ¯”è¾“å‡º
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### å…³é”®ä»£ç 

```c
void FOC_Algorithm_CurrentLoop(
    const FOC_AlgorithmInput_t *input,    // è¾“å…¥ï¼šç”µæµã€è§’åº¦ã€æŒ‡ä»¤
    const FOC_AlgorithmConfig_t *config,  // é…ç½®ï¼šç”µæœºå‚æ•°ã€PI å‚æ•°
    FOC_AlgorithmState_t *state,          // çŠ¶æ€ï¼šç§¯åˆ†é¡¹ã€æ»¤æ³¢å€¼
    FOC_AlgorithmOutput_t *output         // è¾“å‡ºï¼šPWM å ç©ºæ¯”
);
```

---

### Clarke åæ ‡å˜æ¢

Clarke å˜æ¢å°†ä¸‰ç›¸é™æ­¢åæ ‡ç³» (abc) è½¬æ¢ä¸ºä¸¤ç›¸é™æ­¢åæ ‡ç³» (Î±Î²)ï¼Œå®ç°é™ç»´ã€‚

#### æ•°å­¦å…¬å¼

**æ­£å˜æ¢** (abc â†’ Î±Î²)ï¼š

```
[ IÎ± ]     2  [  1    -1/2   -1/2  ] [ Ia ]
[    ]  =  -  [                    ] [    ]
[ IÎ² ]     3  [  0   âˆš3/2  -âˆš3/2  ] [ Ib ]
                                     [ Ic ]
```

ç®€åŒ–å½¢å¼ï¼ˆåˆ©ç”¨ Ia + Ib + Ic = 0ï¼‰ï¼š

```
IÎ± = Ia
IÎ² = (Ib - Ic) / âˆš3
```

**é€†å˜æ¢** (Î±Î² â†’ abc)ï¼š

```
Va = VÎ±
Vb = -1/2Â·VÎ± + (âˆš3/2)Â·VÎ²
Vc = -1/2Â·VÎ± - (âˆš3/2)Â·VÎ²
```

#### å®ç°ä»£ç 

```c
void Clarke_Transform(float Ia, float Ib, float Ic, 
                      float *Ialpha, float *Ibeta)
{
    *Ialpha = Ia;
    *Ibeta = (Ib - Ic) * MATH_ONE_BY_SQRT3;  // 1/âˆš3 é¢„è®¡ç®—
}
```

**ä¼˜åŒ–è¯´æ˜**ï¼š
- ä½¿ç”¨ç®€åŒ–å…¬å¼ï¼Œå‡å°‘ä¹˜æ³•è¿ç®—
- é¢„è®¡ç®—å¸¸æ•° `1/âˆš3`ï¼Œé¿å…é™¤æ³•

---

### Park åæ ‡å˜æ¢

Park å˜æ¢å°†ä¸¤ç›¸é™æ­¢åæ ‡ç³» (Î±Î²) è½¬æ¢ä¸ºä¸¤ç›¸æ—‹è½¬åæ ‡ç³» (dq)ï¼Œä½¿äº¤æµé‡å˜ä¸ºç›´æµé‡ã€‚

#### æ•°å­¦å…¬å¼

**æ­£å˜æ¢** (Î±Î² â†’ dq)ï¼š

```
[ Id ]   [  cosÎ¸   sinÎ¸ ] [ IÎ± ]
[    ] = [              ] [    ]
[ Iq ]   [ -sinÎ¸   cosÎ¸ ] [ IÎ² ]
```

å±•å¼€ï¼š

```
Id =  IÎ±Â·cosÎ¸ + IÎ²Â·sinÎ¸
Iq = -IÎ±Â·sinÎ¸ + IÎ²Â·cosÎ¸
```

**é€†å˜æ¢** (dq â†’ Î±Î²)ï¼š

```
[ VÎ± ]   [ cosÎ¸  -sinÎ¸ ] [ Vd ]
[    ] = [             ] [    ]
[ VÎ² ]   [ sinÎ¸   cosÎ¸ ] [ Vq ]
```

å±•å¼€ï¼š

```
VÎ± = VdÂ·cosÎ¸ - VqÂ·sinÎ¸
VÎ² = VdÂ·sinÎ¸ + VqÂ·cosÎ¸
```

#### å®ç°ä»£ç 

```c
void Park_Transform(float Ialpha, float Ibeta, float theta, 
                    float *Id, float *Iq)
{
    float sin_val, cos_val;
    Trig_FastSinCos(theta, &sin_val, &cos_val);  // å¿«é€Ÿä¸‰è§’å‡½æ•°
    
    *Id = Ialpha * cos_val + Ibeta * sin_val;
    *Iq = -Ialpha * sin_val + Ibeta * cos_val;
}
```

**ä¼˜åŒ–è¯´æ˜**ï¼š
- ä½¿ç”¨å¿«é€Ÿä¸‰è§’å‡½æ•°ï¼ˆæ³°å‹’çº§æ•° + æŸ¥æ‰¾è¡¨ï¼‰
- `sin` å’Œ `cos` åŒæ—¶è®¡ç®—ï¼Œé¿å…é‡å¤

---

### SVPWM è°ƒåˆ¶

ç©ºé—´çŸ¢é‡ PWM æ˜¯ä¸€ç§é«˜æ•ˆçš„ PWM è°ƒåˆ¶æ–¹æ³•ï¼Œå¯ä»¥æœ€å¤§åŒ–çº¿æ€§è°ƒåˆ¶èŒƒå›´ï¼ˆæå‡ 15.5%ï¼‰ã€‚

#### æ•°å­¦åŸç†

**çº¿æ€§è°ƒåˆ¶èŒƒå›´**ï¼š

- ä¼ ç»Ÿ SPWM æœ€å¤§å¹…å€¼ï¼š`Vmax = Vbus/2`
- SVPWM æœ€å¤§å¹…å€¼ï¼š`Vmax = Vbus/âˆš3 â‰ˆ 0.577Â·Vbus`
- æå‡æ¯”ä¾‹ï¼š`(1/âˆš3)/(1/2) = 2/âˆš3 â‰ˆ 1.155` (æå‡ 15.5%)

#### ä¸­ç‚¹æ³¨å…¥æ³•

SVPWM çš„å®ç°é‡‡ç”¨**ä¸­ç‚¹æ³¨å…¥æ³•**ï¼ˆä¹Ÿç§°ä¸ºé›¶åºç”µå‹æ³¨å…¥ï¼‰ï¼š

**æ­¥éª¤1 - å½’ä¸€åŒ–ç”µå‹**ï¼š

```
V'Î± = VÎ± / (Vbus Â· 2/3)
V'Î² = VÎ² / (Vbus Â· 2/3)
```

**æ­¥éª¤2 - è®¡ç®—ä¸‰ç›¸è°ƒåˆ¶æ³¢**ï¼ˆé€† Clarkeï¼‰ï¼š

```
Va = V'Î±
Vb = -1/2Â·V'Î± + (âˆš3/2)Â·V'Î²
Vc = -1/2Â·V'Î± - (âˆš3/2)Â·V'Î²
```

**æ­¥éª¤3 - è®¡ç®—é›¶åºç”µå‹**ï¼ˆä¸­ç‚¹æ³¨å…¥ï¼‰ï¼š

```
Vcom = [max(Va,Vb,Vc) + min(Va,Vb,Vc)] / 2
```

**æ­¥éª¤4 - ç”Ÿæˆæœ€ç»ˆå ç©ºæ¯”**ï¼š

```
Da = 0.5 + Va - Vcom
Db = 0.5 + Vb - Vcom
Dc = 0.5 + Vc - Vcom
```

#### è¿‡è°ƒåˆ¶å¤„ç†

å½“ç”µå‹çŸ¢é‡è¶…å‡ºå¯è°ƒåˆ¶èŒƒå›´æ—¶ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾ï¼š

```
if (Vmax - Vmin) > 1.0:
    scale = 1.0 / (Vmax - Vmin)
    Va, Vb, Vc *= scale
```

#### å®ç°ä»£ç 

```c
int SVPWM_Modulate(float Valpha, float Vbeta, float Vbus, 
                   float *Ta, float *Tb, float *Tc)
{
    // 1. å½’ä¸€åŒ–
    float mod_alpha = Valpha / (Vbus * MATH_2_BY_3);
    float mod_beta = Vbeta / (Vbus * MATH_2_BY_3);
    
    // 2. é€† Clarkeï¼ˆè®¡ç®—ä¸‰ç›¸è°ƒåˆ¶æ³¢ï¼‰
    float Va = mod_alpha;
    float Vb = -0.5f * mod_alpha + MATH_SQRT3_BY_2 * mod_beta;
    float Vc = -0.5f * mod_alpha - MATH_SQRT3_BY_2 * mod_beta;
    
    // 3. å¯»æ‰¾æœ€å¤§æœ€å°å€¼ + é›¶åºç”µå‹æ³¨å…¥
    float Vmax = fmax(Va, fmax(Vb, Vc));
    float Vmin = fmin(Va, fmin(Vb, Vc));
    float Vcom = 0.5f * (Vmax + Vmin);
    
    // 4. è¿‡è°ƒåˆ¶å¤„ç†
    if (Vmax - Vmin > 1.0f) {
        float scale = 1.0f / (Vmax - Vmin);
        Va *= scale; Vb *= scale; Vc *= scale;
        Vcom = 0.5f * (Vmax * scale + Vmin * scale);
    }
    
    // 5. è®¡ç®—å ç©ºæ¯”
    *Ta = Math_Clamp(0.5f + Va - Vcom, 0.0f, 1.0f);
    *Tb = Math_Clamp(0.5f + Vb - Vcom, 0.0f, 1.0f);
    *Tc = Math_Clamp(0.5f + Vc - Vcom, 0.0f, 1.0f);
    
    return 0;
}
```

---

## æ•°å­¦å…¬å¼è¯¦è§£

### 1. ç”µæµç¯ PI æ§åˆ¶å™¨

**è¿ç»­åŸŸæ§åˆ¶å¾‹**ï¼š

```
V(s) = KpÂ·E(s) + (Ki/s)Â·E(s)
å…¶ä¸­è¯¯å·®ï¼šE = Iref - Ifeedback
```

**ç¦»æ•£åŒ–ï¼ˆå‰å‘æ¬§æ‹‰ï¼‰**ï¼š

```
Vpi(k) = KpÂ·e(k) + I(k)
I(k+1) = I(k) + KiÂ·e(k)Â·Ts
```

**æŠ—ç§¯åˆ†é¥±å’Œï¼ˆBack-calculationï¼‰**ï¼š

å½“ç”µå‹é¥±å’Œæ—¶ï¼Œå›é¦ˆé¥±å’Œè¯¯å·®åˆ°ç§¯åˆ†å™¨ï¼š

```
I(k+1) = I(k) + KiÂ·e(k)Â·Ts + KbÂ·(Vsat - Vraw)Â·Ts
```

å…¶ä¸­ï¼š
- `Kb`ï¼šæŠ—é¥±å’Œå¢ç›Šï¼ˆé€šå¸¸å– Kiï¼‰
- `Vsat`ï¼šé¥±å’Œåçš„ç”µå‹
- `Vraw`ï¼šé¥±å’Œå‰çš„ç”µå‹

### 2. å‰é¦ˆè§£è€¦

ç”µæœº dq è½´ç”µå‹æ–¹ç¨‹ï¼š

```
Vd = RsÂ·Id + LsÂ·(dId/dt) - Ï‰eÂ·LsÂ·Iq
Vq = RsÂ·Iq + LsÂ·(dIq/dt) + Ï‰eÂ·(LsÂ·Id + Î»)
```

å…¶ä¸­ï¼š
- `Ï‰e`ï¼šç”µè§’é€Ÿåº¦
- `Î»`ï¼šæ°¸ç£ä½“ç£é“¾

**è§£è€¦å‰é¦ˆé¡¹**ï¼š

```
Vd_ff = -Ï‰eÂ·LsÂ·Iq
Vq_ff = Ï‰eÂ·(LsÂ·Id + Î»)
```

**æ€»è¾“å‡º**ï¼š

```
Vd = Vd_pi + kffÂ·Vd_ff
Vq = Vq_pi + kffÂ·Vq_ff
```

å…¶ä¸­ `kff` æ˜¯è§£è€¦å¢ç›Šï¼Œé€šå¸¸ä¸º 0.8~1.0ã€‚

### 3. ç”µæµç¯å¸¦å®½è®¾è®¡ï¼ˆIMC æ–¹æ³•ï¼‰

æ ¹æ®å†…æ¨¡æ§åˆ¶ï¼ˆInternal Model Controlï¼‰ç†è®ºï¼š

```
Kp = Ls Â· Ï‰c
Ki = Rs Â· Ï‰c
```

å…¶ä¸­ `Ï‰c = 2Ï€fc` æ˜¯æœŸæœ›çš„é—­ç¯å¸¦å®½ï¼ˆrad/sï¼‰ã€‚

**å»ºè®®å€¼**ï¼š
- ç”µæµç¯å¸¦å®½ fcï¼š500 Hz ~ 2000 Hz
- é€Ÿåº¦ç¯å¸¦å®½ï¼šç”µæµç¯çš„ 1/5 ~ 1/10
- ä½ç½®ç¯å¸¦å®½ï¼šé€Ÿåº¦ç¯çš„ 1/5 ~ 1/10

### 4. ç”µæµåé¦ˆæ»¤æ³¢å™¨

ä¸€é˜¶ä½é€šæ»¤æ³¢å™¨ï¼ˆç¦»æ•£åŒ–ï¼‰ï¼š

```
Ifilt(k+1) = Ifilt(k) + Î±Â·(Imeas(k) - Ifilt(k))
```

å…¶ä¸­æ»¤æ³¢å™¨ç³»æ•°ï¼š

```
Î± = (Ï‰cÂ·Ts) / (1 + Ï‰cÂ·Ts),  Ï‰c = 2Ï€fc
```

- `fc`ï¼šæˆªæ­¢é¢‘ç‡
- `Ts`ï¼šé‡‡æ ·å‘¨æœŸ

---

## æ€§èƒ½ä¼˜åŒ–

### 1. å¿«é€Ÿä¸‰è§’å‡½æ•°

ä½¿ç”¨æ³°å‹’çº§æ•°å±•å¼€ + æŸ¥æ‰¾è¡¨ä¼˜åŒ–ï¼š

- **ç²¾åº¦**ï¼šè¯¯å·® < 0.1%
- **é€Ÿåº¦**ï¼šçº¦ 5 å€äº `math.h`
- **å†…å­˜**ï¼šæ— æŸ¥æ‰¾è¡¨ï¼ˆçº¯è®¡ç®—ï¼‰

### 2. å¸¸æ•°é¢„è®¡ç®—

åœ¨ `math_common.h` ä¸­é¢„å®šä¹‰å¸¸ç”¨å¸¸æ•°ï¼š

```c
#define MATH_PI              3.14159265358979323846f
#define MATH_SQRT3           1.73205080756887729352f
#define MATH_SQRT3_BY_2      0.86602540378443864676f
#define MATH_ONE_BY_SQRT3    0.57735026918962576451f
#define MATH_2_BY_3          0.66666666666666666667f
```

### 3. å†…è”å‡½æ•°

å…³é”®å·¥å…·å‡½æ•°ä½¿ç”¨ `static inline`ï¼š

```c
static inline float Math_Clamp(float value, float min, float max) {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}
```

---

## ä½¿ç”¨ç¤ºä¾‹

### åˆå§‹åŒ–

```c
// 1. å‡†å¤‡é…ç½®
FOC_AlgorithmConfig_t config = {
    .Rs = 0.5f,                    // å®šå­ç”µé˜» [Î©]
    .Ls = 0.001f,                  // å®šå­ç”µæ„Ÿ [H]
    .flux = 0.01f,                 // æ°¸ç£ä½“ç£é“¾ [Wb]
    .pole_pairs = 21,              // æå¯¹æ•°
    
    .Kp_current_d = 1.0f,          // dè½´ Kp
    .Ki_current_d = 100.0f,        // dè½´ Ki
    .Kp_current_q = 1.0f,          // qè½´ Kp
    .Ki_current_q = 100.0f,        // qè½´ Ki
    .Kb_current = 100.0f,          // æŠ—é¥±å’Œå¢ç›Š
    
    .Ts_current = 0.00005f,        // é‡‡æ ·å‘¨æœŸ (20kHz)
    .voltage_limit = 48.0f,        // ç”µå‹é™åˆ¶ [V]
    .current_limit = 10.0f,        // ç”µæµé™åˆ¶ [A]
    
    .enable_decoupling = true,     // å¯ç”¨è§£è€¦
    .decoupling_gain = 0.9f,       // è§£è€¦å¢ç›Š
    .current_filter_fc = 1000.0f   // æ»¤æ³¢å™¨æˆªæ­¢é¢‘ç‡ [Hz]
};

// 2. éªŒè¯é…ç½®
if (!FOC_Algorithm_ValidateConfig(&config)) {
    // é…ç½®æ— æ•ˆï¼Œå¤„ç†é”™è¯¯
}

// 3. åˆå§‹åŒ–çŠ¶æ€
FOC_AlgorithmState_t state;
FOC_Algorithm_InitState(&state);
```

### è¿è¡Œæ—¶æ§åˆ¶

```c
void FOC_CurrentLoop_IRQ(void) {
    // 1. å‡†å¤‡è¾“å…¥æ•°æ®
    FOC_AlgorithmInput_t input = {
        .Ia = ADC_GetCurrent_A(),
        .Ib = ADC_GetCurrent_B(),
        .Ic = ADC_GetCurrent_C(),
        .Vbus = ADC_GetBusVoltage(),
        .theta_elec = Encoder_GetElecAngle(),
        .omega_elec = Encoder_GetElecVelocity(),
        
        .Id_ref = 0.0f,            // dè½´ç”µæµæŒ‡ä»¤ï¼ˆé€šå¸¸ä¸º0ï¼‰
        .Iq_ref = torque_cmd / 1.5f / flux,  // qè½´ç”µæµæŒ‡ä»¤
        .enabled = motor_enabled
    };
    
    // 2. æ‰§è¡Œ FOC ç®—æ³•
    FOC_AlgorithmOutput_t output;
    FOC_Algorithm_CurrentLoop(&input, &config, &state, &output);
    
    // 3. è¾“å‡º PWM
    PWM_SetDuty_A(output.Ta);
    PWM_SetDuty_B(output.Tb);
    PWM_SetDuty_C(output.Tc);
    
    // 4. æ£€æŸ¥çŠ¶æ€
    if (output.voltage_saturated) {
        // ç”µå‹é¥±å’Œï¼Œå¯èƒ½éœ€è¦é™ä½ç”µæµæŒ‡ä»¤
    }
    if (output.current_limited) {
        // ç”µæµå·²è¢«é™å¹…
    }
}
```

### PI å‚æ•°è‡ªåŠ¨è®¡ç®—

```c
// æ ¹æ®æœŸæœ›å¸¦å®½è‡ªåŠ¨è®¡ç®— PI å‚æ•°
float Kp, Ki;
FOC_Algorithm_CalculateCurrentGains(
    motor_Rs,          // ç”µé˜»
    motor_Ls,          // ç”µæ„Ÿ  
    800.0f,            // æœŸæœ›å¸¦å®½ 800 Hz
    &Kp, &Ki
);

config.Kp_current_d = Kp;
config.Ki_current_d = Ki;
config.Kp_current_q = Kp;
config.Ki_current_q = Ki;
```

---

## å¸¸è§é—®é¢˜

### Q1: ä¸ºä»€ä¹ˆ Id_ref é€šå¸¸è®¾ä¸º 0ï¼Ÿ

åœ¨è¡¨è´´å¼æ°¸ç£åŒæ­¥ç”µæœºï¼ˆSPMSMï¼‰ä¸­ï¼Œd è½´ç”µæµä¸äº§ç”Ÿè½¬çŸ©ï¼Œåªäº§ç”Ÿç£åœºï¼Œä¼šå¢åŠ é“œæŸã€‚å› æ­¤é€šå¸¸ä»¤ `Id = 0`ï¼Œä»…é€šè¿‡ `Iq` æ§åˆ¶è½¬çŸ©ï¼ˆç§°ä¸º `id = 0` æ§åˆ¶ç­–ç•¥ï¼‰ã€‚

### Q2: å¦‚ä½•è°ƒè¯• PI å‚æ•°ï¼Ÿ

1. å…ˆè®¾ç½®ä¸€ä¸ªè¾ƒå°çš„ Kpï¼ˆå¦‚ 0.1ï¼‰ï¼ŒKi = 0
2. é€æ­¥å¢å¤§ Kp ç›´åˆ°å‡ºç°æŒ¯è¡
3. å°† Kp å‡åŠ
4. é€æ­¥å¢å¤§ Ki ç›´åˆ°ç¨³æ€è¯¯å·®æ¶ˆé™¤
5. å¯ä½¿ç”¨ IMC æ–¹æ³•å¿«é€Ÿè®¡ç®—åˆå€¼

### Q3: ç”µæµç¯å¸¦å®½å¦‚ä½•é€‰æ‹©ï¼Ÿ

- **ä¸‹é™**ï¼šé«˜äºé€Ÿåº¦ç¯å¸¦å®½ 5~10 å€
- **ä¸Šé™**ï¼šä½äº PWM é¢‘ç‡çš„ 1/10ï¼ˆé¿å…æ··å ï¼‰
- **æ¨èå€¼**ï¼š20kHz PWM â†’ 500~1500Hz å¸¦å®½

---

## å‚è€ƒèµ„æ–™

- **ç»å…¸æ•™æ**ï¼šã€ŠçŸ¢é‡æ§åˆ¶ä¸ç›´æ¥è½¬çŸ©æ§åˆ¶ã€‹- å¼ å…´ã€æœå°‘æ­¦
- **è‹±æ–‡èµ„æ–™**ï¼š*Vector Control of AC Machines* - Peter Vas
- **åº”ç”¨æ‰‹å†Œ**ï¼š[Texas Instruments - SVPWM Application Note](https://www.ti.com/lit/pdf/sprabs0)

---

**æœ€åæ›´æ–°**ï¼š2026-01-31  
**ç»´æŠ¤è€…**ï¼šFalconFoc Project Team