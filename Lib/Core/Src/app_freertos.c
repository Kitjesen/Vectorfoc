/**
 * @file    app_freertos.c
 * @brief   FreeRTOS task creation and OS hooks
 * @note    Generated by STM32CubeMX, customized for VectorFOC
 * Copyright (c) 2024 STMicroelectronics. All rights reserved.
 */

#include "FreeRTOS.h"
#include "cmsis_os.h"
#include "main.h"
#include "task.h"

#include "rtos/rtos_tasks.h"
#include "usb_device.h"

/* Task handles */
osThreadId defaultTaskHandle;
osThreadId guardtaskHandle;
osThreadId customtaskHandle;

/* Task entry point declarations (implemented in Src/APP/rtos/) */
void StartDefaultTask(void const *argument);
void StartGuardTask(void const *argument);
void StartCustomTask(void const *argument);

void MX_FREERTOS_Init(void);

/* Static allocation for idle task */
void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize);

/* OS hook prototypes */
void vApplicationIdleHook(void);
void vApplicationStackOverflowHook(xTaskHandle xTask, signed char *pcTaskName);

__weak void vApplicationIdleHook(void) {
  /* Called on each idle task iteration. Must never block. */
}

__weak void vApplicationStackOverflowHook(xTaskHandle xTask,
                                          signed char *pcTaskName) {
  /* Called when stack overflow is detected (configCHECK_FOR_STACK_OVERFLOW) */
}

static StaticTask_t xIdleTaskTCBBuffer;
static StackType_t xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
                                   StackType_t **ppxIdleTaskStackBuffer,
                                   uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}

/**
 * @brief  FreeRTOS initialization - create all application tasks.
 */
void MX_FREERTOS_Init(void) {
  /* Debug task: USB/VOFA data output (1kHz) */
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);

  /* Guard task: motor safety monitoring + LED (200Hz) */
  osThreadDef(guardtask, StartGuardTask, osPriorityNormal, 0, 256);
  guardtaskHandle = osThreadCreate(osThread(guardtask), NULL);

  /* Communication task: CAN command processing (500Hz) */
  osThreadDef(customtask, StartCustomTask, osPriorityAboveNormal, 0, 1024);
  customtaskHandle = osThreadCreate(osThread(customtask), NULL);
}
